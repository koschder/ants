\section{Breitensuche}
\label{subsec:module.Suchalgorithmen.Breitensuche}
Die Breitensuche (engl. Breadth First Search (\gls{BFS})) war eine der Neuimplementierungen während der Bachelorarbeit. Wir verwenden diese Suche um die Umgebung einer Ameise oder eines Hügels nach Futter, Gegnern usw. zu scannen. Man könnte die \gls{BFS} auch für die Pfadsuche verwenden, dies wäre aber sehr ineffizient. Im Klassendiagramm ist zu sehen auf welchen drei Methoden die Breitensuche aufbaut.

Der Algorithmus für die Breitensuche ist in \cite{AIMA} beschrieben und wurde nach dieser Beschreibung implementiert.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{91_bilder/BFS}
\caption{Breitensuche Klassendiagramm}
\label{fig:BFS}
\end{figure}

Die Breitensuche wurde generisch implementiert, so dass sie vielseitig einsetzbar ist. So können zum Beispiel mittels 'GoalTest' je nach Anwendungsfall die Tiles beschrieben werden die gesucht sind. Folgende Breitensuche findet die Ameise welche am nächsten bei einem Food-Tile <r:20,c:16> ist. Die Suche wird initialisiert indem im Konstruktor die Spielkarte mitgegeben wird, welche durchforscht wird. Zusätzlich gilt die Einschränkung das die Breitensuche nur 40 Tiles durchsuchen darf, was einem Radius von zirka 7 Zellen entspricht. Falls keine Ameise gefunden wird gibt der Algorithmus NULL zurück.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption={Anwendungsbeispiel Breitensuche}]
AntsBreadthFirstSearch bfs = new AntsBreadthFirstSearch(Ants.getWorld());
Tile food = new Tile(20,16);
Tile antClosestToFood = bfs.findSingleClosestTile(food, 40, new GoalTest() {
      @Override
      public boolean isGoal(Tile tile) {
          return isAntOnTile(tile);
      }
  });
\end{lstlisting}

Es ist auch möglich mehrere Tiles zurück zu bekommen. Dazu wird die Methode \texttt{findClosestTiles(...)} aufgerufen.\\
\\
Der gleiche Algorithmus kann aber auch alle passierbaren Tiles in einem gewissen Umkreis zurückgeben. Dies haben wir unter anderem beim Initialisieren der DefendHillMission verwendet. Wir berechnen beim Erstellen der Mission die passierbaren Zellen rund um den Hügel. Runde für Runde prüfen wir diese Tiles auf gegnerische Ameisen um die entsprechenden Verteidigungsmassnahmen zu ergreifen. Der Parameter controlAreaRadius2 definiert den Radius des 'Radars' und kann je nach Profil unterschiedlich eingestellt werden.

Dieser Flood Fill Algorithmus ist praktisch identisch mit der Breitensuche. Eine Beschreibung von Flood Fill befindet sich in \cite{ARTIFICIALINTELLIGENCEFORGAMES}.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption={Anwendungsbeispiel FloodFill}]
public DefendHillMission(Tile myhill) {
    this.hill = myhill;
    BreadthFirstSearch bfs = new BreadthFirstSearch(Ants.getWorld());
    tilesAroundHill = bfs.floodFill(myhill, controlAreaRadius2);
}
\end{lstlisting}


Um die Aufrufe der Suche im Ants-Umfeld einfacher zu gestalten haben wir die Breitensuche für unseren Bot mit folgenden selbst-sprechenden Methoden erweitert.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{91_bilder/BFSants}
\caption{Breitensuche Ants-spezifisch}
\label{fig:BFSants}
\end{figure}

\subsection{Warum Breitensuche?}
\label{subsec:module.Suchalgorithmen.Breitensuche.Alternativen}
Bei der Wahl des Suchalgorithmus orientierten wir uns stark an \cite[S.~64-109]{AIMA}, wo die wichtigsten Suchalgorithmen beschrieben und nach verschiedenen Kriterien beurteilt werden. Für eine detailliere Diskussion über die Eigenschaften der Algorithmen sei auf diese Seiten verwiesen; an dieser Stelle wollen wir nur kurz aufzeigen, nach welchen Kriterien wir uns für die Breitensuche entschieden haben.

Abgesehen von der Pfadsuche, bei der wir auf die heuristischen Algorithmen A* und HPA* setzten, waren unsere Anforderungen bei der Suche meist so geartet, dass eine Heuristik entweder nicht existiert, oder keine Vorteile bringt. Wenn wir beispielsweise für ein Nahrungs-\gls{Tile} die nächste Ameise suchen wollen, ist das Ziel der Suche ja nicht bekannt, und daher kann keine sinnvolle Heuristik definiert werden. Es blieb also nur die Frage, welche der verfügbaren nicht-heuristischen Algorithmen wir einsetzen wollten. 

Die wichtigsten Anforderungen an den Such-Algorithmus waren die Vollständigkeit (Wenn eine Lösung existiert, muss sie gefunden werden), und die Optimalität (Eine gefundene Lösung muss die kleinsten Kosten aller existierenden Lösungen haben). Damit fiel bereits die Tiefensuche weg. Die Uniform-Cost Suche machte im Kontext von Ants keinen Sinn, da in diesem Spiel jeder Schritt immer die Kosten 1 hat. Eine Bidirektionale Suche war ebenfalls nicht praktikabel, da wir ja das Ziel der Suche meist nicht kennen. Daher mussten wir uns lediglich noch zwischen der Iterativen Tiefensuche und der Breitensuche entscheiden; die Entscheidung fiel zugunsten der Breitensuche aus, weil sie einfacher zu implementieren ist, und weil wir damit auch gleich einen geeigneten Flood Fill Algorithmus implementieren konnten.

Was für unsere Entscheidung keine Rolle spielte, waren die Zeit- und Raum-Komplexität der Algorithmen; die konkreten Anwendungsfälle für die Suche waren klein genug, dass die Unterschiede vernachlässigbar waren.

\subsection{Barrier (Sperre)}
\label{subsec:module.Suchalgorithmen.Breitensuche.Barrier}

Eine Erweiterung der Breitensuche ermöglicht uns eine Sperre in der Umgebung eines Ortes zu finden. Diese Verwenden wir in der DefendHillMission zum Verteidigen des eigenen Hügels. Es kann nur eine Sperre (engl. Barrier) gefunden werden wenn das Gelände dazu passt. Die Abbildung \ref{fig:search.barrier} zeigt eine solche gefundene Sperre. Auf dieser Höhe wird der Hügel verteidigt.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{91_bilder/barrier}
\caption[Barrier Illustration]{Auf der orangen Sperre werden die Ameisen zur Verteidigung des Hügel positioniert.}
\label{fig:search.barrier}
\end{figure}

Der Algorithmus ist in der Methode \texttt{getBarrier(...)} implementiert. Diese wird aufgerufen mit den Parametern \texttt{tileToProtect} (Ort der durch eine Sperre geschützt werden soll), \texttt{viewRadiusSquared} (den Sichtradius der Einheiten), denn die Sperre soll weiter entfernt sein als der Sichtradius, damit die gegnerischen Einheiten nicht sehen was sich dahinter verbirgt. Der dritte Parameter \texttt{maximumBarrierSize} definiert, welche Breite die Sperre maximal haben darf.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption={Algorithmus für Barrier-Suche}]
public Barrier getBarrier(final Tile tileToProtect, int viewRadiusSquared, int maximumBarrierSize) {

	//BFS for getting the amount of tiles in view radius around the location to defend.
	int amount = [...]
	Barrier smallestBarrier = null;
	List<Tile> tiles = get (amount + 30) tiles around the location to defend.
	
	// for loop start at the first tile not in view radius
	for(int i = amount;i<tiles.size(); i++){       
		Tile t = tiles.get(i);
		
		//vertical check
		if(!barrierVerticalInvalid.contains(t)){
			Barrier b = get vertical barrier on position of Tile t
			if(b is smaller than 5 Tiles && smaller than smallestBarrier){
				if(is barrier the only exit out of the location to defend){
						smallestBarrier = b;
				}else{
						 //add all tiles of the invaild barrier
						barrierVerticalInvalid.add(b.getTiles());
				}    					      		
			}else{
				 //add all tiles of the invaild barrier
				barrierVerticalInvalid.add(b.getTiles());
			}
		}
		
		//horizontal check
		if(!barrierHorizontalInvalid.contains(t)){
			Barrier b = get horiontal barrier on position of Tile t
			if(b is smaller than 5 Tiles && smaller than smallestBarrier){
				if(is barrier the only exit out of the location to defend){
						smallestBarrier = b;
				}else{
						 //add all tiles of the invalid barrier
						barrierHorizontalInvalid.add(b.getTiles());
				}    					      		
			}else{
				//add all tiles of the invalid barrier
				barrierHorizontalInvalid.add(b.getTiles());
			}
		}	
	}
}
\end{lstlisting}

Dank dem Abspeichern der ungültigen Tiles aller zu breiten Sperren in die Listen \texttt{barrierHorizontalInvalid} und \texttt{barrierVerticalInvalid} konnte der Algorithmus markant schneller gemacht werden. Für diese Tiles muss nicht nochmals eine Sperre berechnet werden. Auch die if-Abfrage \texttt{barrier is the only exit out of the location to defend} muss nicht mehr oft aufgerufen werden, den hinter dieser Abfrage steht nämlich wiederum ein Test mit der Breitensuche. Dieser zusätzliche Test mit der Breitensuche ist viel teurer als das Zwischenspeichern der Tiles aus welchen keine gültige Sperre gemacht werden konnte.\\
\\
Im Nachhinein hat sich ergeben, dass nicht unbedingt die schmalste Sperre die Beste wäre, sondern jede bei welche der Gegner, geländebedingt, weniger Einheiten aufstellen kann. So wäre in Abbildung \ref{fig:search.barrier} eine Sperre zwei Zellen östlicher besser, den der Gegner könnte beim Angriff nur mit vier Einheiten vorrücken, die Verteidigung wäre aber mit sechs Einheiten auf einer Linie deutlich stärker. Die Zeit hat aber hier leider nicht gereicht, den Algorithmus weiter zu verfeinern.