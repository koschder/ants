\section{Missionen}
\label{sec:module.Missionen}

Missionen sind das Herzstück unserer Arbeit. Eine Mission dauert über mehrere Spielzüge und berechnet für jede teilnehmende Ameise welches ihre nächste Bewegung ist. Nachfolgende Darstellung zeigt, dass alle Missionen von der abstrakten BaseMission abstammen und die BaseMission das Interface Mission implementiert. Die Lebensdauer einer Mission hängt davon ab, ob sie ihr Ziel erreicht oder ob sie schon früher abgebrochen wird. Ziel und Abbruchbedingungen sind je nach Mission unterschiedlich und werden im jeweiligen Abschnitt erklärt.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{91_bilder/Missions}
\caption{Missionen und ihre Hierarchie}
\label{fig:missions}
\end{figure}


\subsection{BaseMission}
\label{subsec:module.Mission.BaseMission}

Diese Klasse hat zwei Verwendungszwecke, erstens implementiert sie die von Interface Mission vorgegebene Methoden und zweitens stellt sie Funktionen zur Verfügung die von den spezifischen Missionen verwendet werden. Die wichtigsten Funktionalitäten sind hier mit Erklärung aufgelistet.

\begin{itemize}
	\item  \textbf{abandonMission():} Abbrechen der Mission
	\item  \textbf{addAnt():} Ameise der Mission hinzufügen, in der Population als beschäftigt markieren.
	\item  \textbf{doAnyMove(Ant a):} Für die mitgegebene Ameise irgendein Zug in eine der vier Richtung bestimmen.
	\item  \textbf{doMoveInDirection(Ant ant, Tile target):} Ein Zug in eine bestimmte Richtung bestimmen.
	\item  \textbf{gatherAnts(...):} Ameisen für die Mission rekrutieren. Die Anzahl Ameisen wird als Parameter mitgegeben. 
	\item  \textbf{moveToNextTileOnPath(Ant a):} Bewegt die Ameise ein Pfadstück weiter auf dem, der Ameisen zugewiesen, Pfad.
	\item  \textbf{putMissionOrder(...):} Wurde ein Befehl für die Ameise gefunden, wird er der Klasse Orders (Verwaltung der Befehle) mitgeteilt.
	\item  \textbf{releaseAnts(int amount):} Ameisen von der Mission entlassen. 
	\item  \textbf{checkEnviroment(...):} Mittels Breitensuche wird die Umgebung der Ameise nach eigenen Hügel, gegnerischen Hügel, gegnerischen Ameisen und Futterzellen gescannt. Je nach Mission wird beim Fund eines solchen Objekt die Mission abgebrochen, oder die Ameise von der Mission entlassen.
\end{itemize}

Nachfolgend werden die spezifischen Missionen erläutert. Tabellarisch werden die Eigenschaften der Missionen aufgelistet, danach folgen detaillierte Informationen zur Mission.


\subsection{PathMission}
\label{subsec:module.Mission.PathMission}

Precondition: -\\
Creator: (Ersteller): CombatTask, oder ExploreMission\\
Postcondition: Pfad vollständig abgelaufen\\
Max. Ants (Maximale Anzahl Ameisen): 1\\
Max. Missionen: unbegrenzt\\
Valid (Gültigkeit): siehe ExploreMission bzw. CombatTask\\
Gather Ants (Ameisen rekrutieren): Nicht möglich\\
Release Ants (Ameisen entlassen): Nicht möglich\\
\\
Die Pathmission ist eine abstrakte Klasse die von ExploreMission und als anonyme Klasse im CombatTask implementiert wird. Die einzige Funktionalität die angeboten wird ist, eine Ameise, die der Initialisierung mit Pfad mitgegeben wird, auf diesem definierten Pfad zu bewegen.

\subsection{AttackHillMission}
\label{subsec:module.Mission.AttackHillMission}

Precondition: Gegnerischer Hügel sichtbar\\
Creator: AttackHillsTask\\
Postcondition: Gegnerischer Hügel erobert\\
Max. Ants: unbegrenzt\\
Max. Missionen: Je gegnerischen Hügel eine Mission\\
Valid: solange gegnerischer Hügel nicht zerstört ist.\\
Gather Ants: pro Zug max. fünf Ameisen, die im Umkreis von 25 Tiles des gegnerischen Hügel sind.\\
Release Ants: Sicheres Food-Tile in der Nähe. Eigener Hügel in der Nähe der Unterstützung braucht. Wenn Mission im Status ControlHill ist werden alle Ameisen entlassen ausser zwei, diese kontrollieren den Hügel.\\
\\
Diese Mission unterscheidet zwischen den drei verschiedenen Modi ControlEnemyHill,DestroyHill udn AttackEnemyHill. Der Modus wird zu Beginn jeder Runde durch die Methode determineState() definiert.\\
\\
\textbf{ControlEnemyHill}\\
Der Modus ist aktiv wenn, zwei oder mehr eigene Ameise in der Nähe des gegnerischen Hügel sind. Der Gegner aber nur eine Ameise zur Verteidigung hat.\\
Der Status braucht nur zwei Ameisen, jene die am nächsten bei gegnerischen Hügel sind, die anderen werden entlassen. Die übrigen zwei Ameisen positionieren sich auf einer der vier diagonal gelegenen Zellen. Dank dieser Positionierung, werden alle gegnerischen Ameisen die neu aus dem Hügel schlüpfen sofort vernichtet. Der Gegner kann sich so nur durch Ameisen vermehren die aus einem anderen Hügel schlüpfen. (Die Ameisen schlüpfen zufällig aus einem Hügel.) Der Hügel wird erst zerstört wenn das Spiel endet, oder sich der Gegner mit anderen Ameisen dem Hügel nähert.

\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/ControlEnemyHill}
\caption{Ein gegnerischer Hügel wird durch unsere Ameisen (orange) kontrolliert.}
\label{fig:ControlEnemyHill}
\end{figure}

\textbf{DestroyHill}\\
Der Modus ist aktiv wenn, das Spiel 5 Züge vor Spielende ist\\
Wenn dieser Modus eintrifft ist das Spiel fast zu Ende. Deshalb wird versucht mit der Brechstange den Hügel zu erobern indem die Ameisen auf dem kürzesten Weg und ohne Positionierung Richtung gegnerischen Hügel geschickt werden.\\
\\
\textbf{AttackEnemyHill}\\
Der Modus ist aktiv in allen anderen Fällen\\
Alle Angreifer werden nach ihrer Position in lokalen Gruppen zusammen gefasst. Für diese Gruppe wird ein Pfad zum gegnerischen Hügel berechnet. Falls der Pfad länger ist als fünf Tiles wird ein Meilenstein (Milestone) definiert. Nun werden mittels Breitensuche die Gegner zwischen dem Meilenstein und der Gruppe ermittelt. Mit dieser Ausgangslage wird eine AttackingCombatPositioning-Klasse initialisiert. Als Parameter werden die Gruppe, die gegnerischen Ameisen sowie der Meilenstein mitgegeben. Die Klasse berechnet die nächsten Bewegungen der Gruppe. (Details siehe zur Berechnung \ref{sec:module.CombatSituation})
       
\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/AttackHill}
\caption{Die Zweiergruppe ist in Kampfstellung. Vier weitere Ameisen rücken zur Front auf.}
\label{fig:AttackHill}
\end{figure}

\subsection{DefendHillMission}
\label{subsec:module.Mission.DefendHillMission}

Precondition: Keine, Mission wird zu Beginn des Spiels erstellt.\\
Creator: DefendHillTask\\
Postcondition: Eigener Hügel wurde zerstört.\\
Max. Ants: unbegrenzt\\
Max. Missionen: Je eigener Hügel eine Mission\\
Valid: solange eigener Hügel nicht erobert ist.\\
Gather Ants: Mission soll immer mehr Verteidiger haben als Angreifer sich dem Hügel nähern.\\
Release Ants: Keine Angreifer in Sicht, werden die Ameisen (nicht alle) entlassen.\\
\\
Beim Entwickeln dieser Mission haben wir uns folgende Fragen gestellt: Ab welchem Spielzug soll der Hügel bewacht werden? Wie viel Ameisen sollen für die Verteidigung eingesetzt werden? Was wenn der Hügel von mehreren Seiten angegriffen wird? Sollen alle Hügel bewacht werden? Aus diesen Frage ergab sich folgende Implementation: \\
\\
Die DefendHillMission bietet zwei Arten zur Verteidigung an. Die Default-Verteidigung und die Barrier-Verteidigung. Bei der Default-Verteidigung werden die Ameise nahe um den eigenen Hügel zur Verteidigung aufgestellt. Die Barrier-Verteidigung ist nur bei Hügeln möglich die in einer Sackgasse sind, den in diesem Modus wird eine Sperre an der engsten Stelle erstellt. Nachfolgende Abbildung veranschaulicht die beiden Verteidigungsarten.

\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/DefendHillModi}
\caption{Links die Default-Verteidigung, rechts mit einer Barrier (Sperre).}
\label{fig:DefendHillModi}
\end{figure}

Die Art der Verteidigung wird wie folgt definiert. Während dem zehnten Spielzug wird versucht mittels spezieller Breitensuche eine Sperre für den Hügel zu finden. Falls dies gelingt läuft die Mission wird die Sperre erstellt. Dies solange bis eine gegnerische Ameise auf die Höhe der Barriere tritt, dann gehen wir davon aus, dass die Sperre vom Gegner eingenommen wurde, wir wechseln die Verteidigungsart.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption=Die Verteidigungsart wird bestimmt.]
private void determineMode() {
  if (Ants.getAnts().getTurn() == 10) {
      AntsBreadthFirstSearch bfs = new AntsBreadthFirstSearch(Ants.getWorld());
      barrier = bfs.getBarrier(hill, Ants.getWorld().getViewRadius2(), 5);
      if (barrier != null) {
          mode = DefendMode.Barrier;
      }
  } else if (Ants.getAnts().getTurn() > 10 && mode == DefendMode.Barrier) {
	/* if we switched to barrier defend-mode we have to check if we aren't overrun. (enemy ant on barrier) if we are overrun, we switch back to the default mode. */
      for (Tile t : barrier.getBarrier()) {
          if (Ants.getWorld().getIlk(t) == Ilk.ENEMY_ANT) {
              mode = DefendMode.Default;
              break;
          }
    }
}
\end{lstlisting}

\subsubsection{Default-Modus}
\label{subsubsec:module.Mission.DefendHillMission.DefaultModus}

Hier wird jegentlich berechnet, wie viele Ameisen den Hügel angreifen. Die Angreifer und die Verteidiger werden dem DefendingCombatPositioning übergeben, dieses berechnet die Positionen der Ameisen. Es ist einstellbar ab welchem Zug die DefendHillMission Ameisen für die Verteidigung rekrutiert. Zudem kann mit dem Parameter \texttt{DEFENDER\_MORETHAN\_ATTACKERS} definiert werden wie viele Ameisen mehr als die Anzahl Angreifer rekrutiert werden. Ameisen werden von der Mission entlassen wenn weniger Angreifer als Verteidiger, unter der Berücksichtigung des erwähnten Parameter, gezählt werden.

\subsubsection{Barrier-Modus}
\label{subsubsec:module.Mission.DefendHillMission.BarrierModus}

Wie schon erwähnt, kann dieser Modus nur eintreffen wenn die Geländegegebenheiten stimmen. Ziel ist Engpässe auszunutzen um mit möglichst wenigen Ameisen zu verteidigen. Eine weitere Idee der Verwendung von einer Sperre ist, dass durch die Sperre der Gegners die Umgebung dahinter nicht erkunden kann. So bekommt er unseren Hügel nie zu Gesicht und dadurch eventuell auch kein Angriff. Diese Art zu Verteidigen hat den Nachteil, dass die Ameisen welche für die Sperre benötigt werden, entsprechend statisch platziert werden. Diese können dann nicht für andere Aufgaben verwendet werden.\\
\\
Die Sperre wurde gegen Xathis getestet und sie zeigte nur eine geringe Wirkung. Der Bot von Xathis wartet vor der Sperre bis er in Überzahl ist und überrumpeln dann unsere Verteidigung. Erstaunlicher Weise wird die Sperre von Greentea (zweitbester Bot), auch wenn er in Überzahl ist, nicht angegriffen. Gegen diesen Gegner war die Sperre also gutes Mittel zur Verteidigung.\\
\\
Die Funktionsweise ist wie folgt. Es werden je nach Breite der Sperre entsprechend viele Ameisen zur Position der Sperre geschickt um diese aufzubauen. Die Ameisen stellen sich paarweise hintereinander auf, solange keine Gegner in der Nähe sind. So können eigene Ameisen die einer anderen Aufgabe nachgehen die Sperre passieren. Wenn der Gegner sich in Überzahl nähert, wird die Sperre geschlossen. Danach wird das Kampfverhalten dem AttackingCombatPositioning überlassen, welches die Positionierung übernimmt.

\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/barrierCloseExample}
\caption{Die Sperre wird geschlossen und trotz gegnerischer Überzahl nicht angegriffen. (Gegner: Greentea)}
\label{fig:CloseBarrier}
\end{figure}

\subsection{ExploreMission}
\label{subsec:module.Mission.ExploreMission}

Precondition: - \\
Creator: ExploreTask\\
Postcondition: Definierter Erkundungspfad wurde zurückgelegt.\\
Max. Ants: 1\\
Max. Missionen: unbegrenzt\\
Valid: Solange die Ameise ein gültiger Pfad hat.\\
Gather Ants: nicht möglich\\
Release Ants: nicht möglich\\
\\
Die ExploreMission wird verwendet um die Spielkarte zu erkunden. Die Ameise läuft den vom ExploreTask vorgegebenen Pfad ab. Die Mission wird abgebrochen, wenn Futter in der Nähe ist, wenn ein gegnerischer Hügel oder gegnerische Ameisen auftauchen oder wenn ein eigener Hügel in der Nähe Hilfe braucht.

\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/exploreMission}
\caption{Eine Ameise auf einer ExploreMission bewegt sich in Richtung \gls{FogofWar}}
\label{fig:exploreMission}
\end{figure}

\subsection{GatherFoodMission}
\label{subsec:module.Mission.GatherFoodMission}

Precondition: Keine, Mission wird zu Beginn des Spiels erstellt.\\
Creator: GatherFoodTask\\
Postcondition: diese Mission besteht während dem ganzen Spiel \\
Max. Ants: unbegrenzt\\
Max. Missionen: 1\\
Valid: immer\\
Gather Ants: siehe Beschreibung\\
Release Ants: siehe Beschreibung\\

Diese Mission  koordiniert die Futtersuche und verwaltet die Ameisen, welche Futter einsammeln. Es wird nur eine GatherFoodMission zu Beginn des Spiels erstellt. Sie berechnet welche Ameise am nächsten bei einer Futterzelle ist, berechnet den Pfad und schickt die Ameise Zug um Zug in Richtung Futter. Die \texttt{execute()}-Methode der GatherFoodMission sieht wie folgt aus:

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption=Ablauf von \texttt{execute()} während der GatherFoodMission]
@Override
public void execute() {
	// check the existing routes, if they are still valid.
	checkAntsRoutes();
	// gather new ants, relcalculate routes
	gatherAnts();
	// move the ants
	moveAnts();
}
\end{lstlisting}

Bei \textttt{checkAntsRoutes()} wird geprüft ob die Pfadrouten aller Ameisen in der Mission noch gültig sind. Ungültige Pfade sind, wenn die Futterzelle von der eigenen Ameise oder einer gegnerischen Ameise gefressen wurde. Ameisen mit einem ungültigen Pfad werden von der Mission entlassen, können aber in der nächsten Methode \textttt{gatherAnts()}, falls eine Aufgabe gefunden für die Ameise gefunden wird, der Mission wieder beitreten. Die Logik der \textttt{gatherAnts()} Methode ist in folgenden Codebeispiel vereinfacht dargestellt.

TODO CAPTION wird abgeschnitten
\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption=Berechnung welche Ameise welches Futter einsammelt.]
foreach(food on map){
	if(there is an ant in food mission, which is gathering this food tile with a path smaller than 5)
		continue;
	Ant ant = getNearestAntWithBreadthFirstSearch();
	if(ant found)
		possibleRoutes.add(new Route(ant,food));
}
foreach(Route r in possibleRoutes){
	Path path = getPathWithAStar(r);
	if(foodIsTargetedbyOtherAnt()){
			compareDistances()
			if(new path is shorter){
					newGatherFoodRoute(r.ant,r.food,path);
					releaseAnt(otherAnt);
			}
			continue;
	}
	if(hasAlreadyGatherFoodRoute(r.ant)
			takeSmallerRoute();
	else
			newGatherFoodRoute(r.ant,r.food,path);
}
\end{lstlisting}

Zum Schluss folgt die \texttt{moveAnts()}-Methode. Hier werden die Ameisen auf ihrem Pfad zur Futterzelle ein Zug weiter bewegt. Die Züge werden der Orders-Klasse (Befehlsverwaltung) übergeben.

\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/gatherfood}
\caption{Ameisen am Futter einsammeln.}
\label{fig:gatherfood}
\end{figure}

Links ist zu sehen wie für beide Ameisen ein Futterpfad definiert ist, beide Ameisen folgen ihrem Pfad. Zwei Züge später (rechtes Bild) hat die Ameise links ihr Futter eingesammelt und steht für eine neue Aufgabe zur Verfügung. Der beschriebene Algorithmus merkt, dass die Ameise näher an der Futterzelle oben im Bild ist und löst die andere Ameise, welche bis dahin auf das Futter zu steuerte, von der Aufgabe ab. Die rechte Ameise wird von der GahterFoodMission entlassen und geht einer anderen Beschäftigung (hier ExploreMission) nach.

\subsection{Verworfene und nicht verwendete Mission}
\label{subsec:implementation.Tasks.StupidMission}

Wie bereits im Kapitel Task erwähnt war nicht alles programmierte erfolgreich. Hier sind die Missionen aufgelistet die zu den verworfen oder nicht verwendeten Tasks gehören. (Begründungen siehe Tasks)

\begin{itemize}
\item \textbf{SwarmPathMission}
\item \textbf{AttackHillsInFlockMission}
\item \textbf{ConcentrateMission}
\item \textbf{FlockMission}
\end{itemize}