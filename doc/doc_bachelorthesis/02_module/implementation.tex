\chapter{Implementation}
\label{chap:implementation}

\section{Modell}
\label{sec:implementation.Model}
Für die Modellierung habe wir uns auf die nötigsten Klassen beschränkt, um das Modell einfach zu halten. Ein wichtiger Aspekt der Modellierung war dabei die Abbildung des Spiel-Zustands auf State-Klassen, die uns jederzeit Zugriff auf alle bekannten Variablen des Spiels bieten. Einige Informationen können dabei direkt von der Spielengine übernommen werden, die meisten Zustandsinformationen werden aber berechnet.

Die Modellierung der Klassen, die Spielelemente repräsentieren, war etwas einfacher. Hier konnten wir auch einzelne Enumerationen u.ä. aus dem Beispiel-Bot der AI-Challenge übernehmen.

\subsection{State-Klassen}
\label{sec:implementation.State}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{bilder/State}
\caption{State-Klassen (vereinfacht)}
\label{fig:StateClasses}
\end{figure}

Abbildung \ref{fig:StateClasses} zeigt eine \"{U}bersicht über die Zustands-Klassen. Für das Diagramm wurden lediglich die wichtigsten Methoden und Attribute berücksichtigt. Die State-Klassen implementieren alle das Singleton-Pattern.

\subsubsection{Ants}
\label{sec:implementation.State.Ants}
Die Ants Klasse ist die zentrale State-Klasse. Sie bietet auch einfachen Zugriff auf die anderen State-Klassen. Ursprünglich hatten wir alle Methoden, die mit dem Zugriff auf den Spielzustand zu tun hatten, direkt in der Ants Klasse implementiert, haben aber schnell gemerkt, dass das unhandlich wird. Die Ants Klasse dient jetzt vor allem als Container für die anderen State-Klassen und implementiert nur noch einige Methoden, die Zustandsänderungen in verschiedenen Bereichen vornehmen.

\subsubsection{World}
\label{sec:implementation.State.World}
Die World Klasse enthält Informationen zur Spielwelt. Hier wird die Karte abgespeichert, in der für jede Zelle die aktuell bekannten Informationen festgehalten werden. Das beinhaltet die Sichtbarkeit der Zelle und was die Zelle aktuell enthält (Ameise, Nahrung, Wasser, ...). Ausserdem werden Listen geführt, wo sich die eigenen und die bekannten gegnerischen Hügel befinden. Die Klasse bietet Methoden zur Distanzberechnung, gibt Auskunft über einzelne Zellen und darüber, ob sich Nahrung in der Umgebung einer bestimmten Zelle befindet.

\subsubsection{Orders}
\label{sec:implementation.State.Orders}
In der Orders Klasse wird über Befehle und Missionen der einzelnen Ameisen Buch geführt. Die Liste der Befehle wird dabei in jedem Zug geleert und neu befüllt, während die Liste der Missionen zugübergreifend geführt wird. Das zentrale Verwalten der Befehle dient vor allem dazu, sicherzustellen, dass keine widersprüchlichen Befehle ausgegeben werden. (mehrere Befehle für eine Ameise, gleiche Ziel-Koordinaten für mehrere Ameisen, ...)

\subsubsection{Population}
\label{sec:implementation.State.Population}
Die Population Klasse dient der Verwaltung der eigenen und der gegnerischen Ameisen-Völker. Hier werden die Ameisen mit ihren aktuellen Aufenthaltsorten festgehalten. Wenn für eine Ameise ein Befehl ausgegeben wird, wird die Ameise als beschäftigt markiert. \"{U}ber die Methode \texttt{getMyUnemployedAnts()} kann jederzeit eine Liste der Ameisen abgefragt werden, die für den aktuellen Zug noch keine Befehle erhalten haben.

\subsubsection{Clustering}
\label{sec:implementation.State.Clustering}
Die Clustering Klasse dient dem Aufteilen des Spielfeldes in Clusters für die HPA*-Suche (s. Abschnitt \ref{subsec:implementation.Pfadsuche.HPAstar}). Hier werden die berechneten Clusters abgelegt, der Zugriff auf sie erfolgt ebenfalls über die Clustering Klasse.

\subsection{Spiel-Elemente (Welt)}
\label{sec:implementation.Entities.World}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{bilder/Entities_World}
\caption{Spiel-Elemente der Spielwelt (vereinfacht)}
\label{fig:entitiesWorld}
\end{figure}

Abbildung \ref{fig:entitiesWorld} zeigt die wichtigsten Klassen, die die Elemente des Spiels repräsentieren. Der \"Ubersichtlichkeit wegen wurden nur die wichtigsten Attribute und Operationen in das Diagramm aufgenommen.

\subsubsection{Ant}
\label{sec:implementation.Entities.Ant}
Eine Ant gehört immer zu einem Spieler; über die Methode isMine() können unsere eigenen Ameisen identifiziert werden. 
Eine Ameise weiss jeweils in welcher Zelle sie steht. Das Feld nextTile dient der Verfolgung einer Ameise über mehrere Züge -- das Feld wird jeweils aktualisiert, wenn der Ameise ein Befehl ausgegeben wird. Im nächsten Zug können wir dann prüfen ob die Ameise den Befehl korrekt ausführen konnte. Eine Ameise kennt auch die anderen Ameisen in ihrer Umgebung: Über die Methoden getEnemies()/FriendsInRadius() können alle bekannten Freunde und Feinde in einem bestimmten Radius ermittelt werden.

\subsubsection{Tile}
\label{sec:implementation.Entities.Tile}
Das Tile repräsentiert eine Zelle des Spielfelds. Es implementiert das SearchTarget Interface (s. \ref{sec:implementation.Entities.SearchTarget}). Es bietet zudem Methoden für die einfache Distanzberechnung, sowie für das Bestimmen der Richtungen, in der ein anderes Tile liegt.

\subsubsection{Route}
\label{sec:implementation.Entities.Route}
Eine Route repräsentiert eine einfache Start-Ziel Verbindung. Sie hält für eine Ameise die Luftliniendistanz zu einem bestimmten Zielfeld fest.

\subsubsection{Move}
\label{sec:implementation.Entities.Move}
Ein Move entspricht einem Zug einer Ameise. Für ein bestimmtes Tile wird angegeben, in welche Richtung sich die Ameise bewegen soll.

\subsubsection{Ilk}
\label{sec:implementation.Entities.Ilk}
Ilk ist der Typ einer Zelle. Der Ilk einer Tile-Instanz gibt an, was sich gerade in der Zelle befindet. Dies kann ein Gelände-Typ sein, wenn die Zelle ansonsten leer ist, oder es kann eine Ameise, Nahrung, oder ein Hügel sein. Die Ilk-Enumeration bietet Hilfsmethoden, um festzustellen, ob eine Zelle passierbar oder besetzt ist.

\subsubsection{Aim}
\label{sec:implementation.Entities.Aim}
Aim ist einfach eine Repräsentation einer Himmelsrichtung

\subsection{Spiel-Elemente (Suche)}
\label{sec:implementation.Entities.Search}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{bilder/Entities_Search}
\caption{Spiel-Elemente für die Suche (vereinfacht)}
\label{fig:entitiesSearch}
\end{figure}

Abbildung \ref{fig:entitiesSearch} zeigt die wichtigsten Klassen, die für die Pfadsuche verwendet werden. Der \"Ubersichtlichkeit wegen wurden nur die wichtigsten Attribute und Operationen in das Diagramm aufgenommen.

\subsubsection{SearchTarget}
\label{sec:implementation.Entities.SearchTarget}
Das SearchTarget ist ein Interface für Strukturen, die als Suchknoten in der Pfadsuche verwendet werden können. Es definiert die für die Suche nötigen Methoden, wie getSuccessors(), getCost(), oder getPath(). 
Implementierende Klassen sind Edge (repäsentiert eine Kante in einem Cluster) und Tile (repräsentiert eine Zelle des Spielfelds, s. \ref{sec:implementation.Entities.Tile}). Erweiterungen dieser Klassen sind DirectedEdge (eine gerichtete Kante) und Vertex (eine Zelle mit zugehörigen Kanten).

\subsection{Tasks}
\label{sec:implementation.Tasks}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{bilder/Tasks}
\caption{Tasks}
\label{fig:tasks}
\end{figure}
Zu Beginn des Projekts haben wir die wichtigsten Aufgaben einer Ameise identifiziert. Diese Aufgaben wurden als Tasks in eigenen Klassen implementiert. Das Interface Task\footnote{Das Interface ist im Code unter ants.tasks.Bot.Java auffindbar.} definiert eine setup()-Methode welche den Task initiiert, sowie eine perform()-Methode welche den Task ausführt. Im Programm werden die Tasks nach deren Wichtigkeit ausgeführt, was auch der nachfolgenden Reihenfolge entspricht. Jedem Task stehen nur die unbeschäftigten Ameisen zur Verfügung, d.h. jene welchen noch keine Aufgabe zugeteilt wurde.

\subsubsection{MissionTask}
\label{subsec:implementation.Tasks.MissionTask}
Dieser Task prüft alle aktuellen Missionen auf deren Gültigkeit, beispielsweise ob die Ameise der Mission den letzten Zug überlebt hat und die Mission weiterführen kann. Falls gültig, wird der nächste Schritt der Mission ausgeführt.

\subsubsection{GatherFoodTask}
\label{subsec:implementation.Tasks.GatherFoodTask}
Für jedes Food-Tile werden in einem definierbaren Radius r die nächsten Ameisen bestimmt. Danach wird nach aufsteigender Luftliniendistanz mit dem Pfadsuchalgorithmus SIMPLE (s. Abschnitt \ref{subsec:implementation.Pfadsuche.Simple}) oder -- falls dieser keinen Pfad gefunden hat -- mit A* eine passierbare Route gesucht. Wenn ein Pfad existiert, kann mit der Ameise und dem Food-Tile eine GatherFoodMission erstellt werden, welche die Ameise zum Food-Tile führt. Zu jedem Food-Tile wird immer nur eine Ameise geschickt.

\subsubsection{AttackHillsTask}
\label{subsec:implementation.Tasks.AttackHillsTask}
Sobald gegnerische Ameisenhaufen sichtbar sind, sollen diese angegriffen werden. Das Zerstören eines gegnerischen Haufens ist wie erwähnt 2 Punkte wert. Die Kriterien, nach denen eine Pfad zum gegnerischen Haufen gesucht wird, sind die selben wie beim GatherFoodTask, ausser dass mehrere Ameisen das Ziel angreifen können. Es wird eine AttackHillMission erstellt.

\subsubsection{CombatTask}
\label{subsec:implementation.Tasks.CombatTask}
Beim Angriffstask wird berechnet ob wir in einem Kampfgebiet (definiert über den Sichtradius einer Ameise) die Überhand, d.h. mehr Ameisen platziert haben. Falls ja, wird die gegnerische Ameise angegriffen.

\subsubsection{DefendAreaTask}
\label{subsec:implementation.Tasks.DefendAreaTask}
Dieser Task wäre vogesehen um eine Region wie zum Beispiel den eigenen Ameisenhügel zu schützen. Dieser Task wurde im Zuge dieser Arbeit nicht implementiert.

\subsubsection{ExploreTask}
\label{subsec:implementation.Tasks.ExploreTask}
Für alle noch unbeschäftigten Ameisen wird mittels ManhattanDistance der nächste Ort gesucht, der noch nicht sichtbar, also unerforscht ist. Falls ein Pfad mittels Pfadsuchalgorithmus gefunden wird, wird eine ExploreMission (s. Abschnitt \ref{sec:implementation.Missionen}) erstellt. Die Ameise wird den gefundenen Pfad in den nächsten Spielzügen ablaufen.

\subsubsection{FollowTask}
\label{subsec:implementation.Tasks.FollowTask}
Der FollowTask ist für Ameisen angedacht welche aktuell keine Aufgabe haben. Diese Ameisen sollen einer nahe gelegenen, beschäftigten Ameise folgen, damit diese nicht alleine unterwegs ist.

\subsubsection{ClearHillTask}
\label{subsec:implementation.Tasks.ClearHillTask}
Dieser Task bewegt alle Ameisen, welche neu aus unserem Hügel ''schlüpfen``, vom Hügel weg. So werden nachfolgende Ameisen nicht durch diese blockiert.

\subsubsection{ClusteringTask}
\label{subsec:implementation.Tasks.ClusteringTask}
Der ClusteringTask wird als Vorbereitung für den HPA* Algorithmus verwendet. Hier wird für alle sichtbaren Kartenregionen ein Clustering vorgenommen. Das Clustering wird im Kapitel \ref{subsec:implementation.Pfadsuche.HPAstar} im Detail beschreiben.

\subsection{Missionen}
\label{sec:implementation.Missionen}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{bilder/Missions}
\caption{Missionen}
\label{fig:missions}
\end{figure}
Eine Mission dauert über mehrere Spielzüge. Die meisten Missionen (GatherFoodMission, ExploreMission, AttackHillMission, AttackAntMission) sind Pfadmissionen\footnote{Die abstrakte Klasse PathMission ist im Code unter ants.missions.PathMission.java auffindbar.}, bei welchen die Ameise einem vorgegebenen Pfad, der bereits beim Erstellen der Mission berechnet wurde, folgt. 
Die FollowMission ist eine spezielle Mission, mit der eine Ameise einfach einer anderen Ameise hinterherläuft.

Eine Mission kann auch abgebrochen werden, wenn es keinen Sinn mehr macht, sie weiter zu verfolgen. Je nach spezifischer Mission sind aber die Abbruchbedingungen anders. Zum Beispiel die GatherFoodMission ist nur solange gültig wie das Futter noch nicht von einer anderen Ameise eingesammelt wurde.
Abbildung \ref{fig:missions} zeigt einen \"Uberblick über die wichtigsten Missionen und ihre Hierarchie.


\section{Bot}
\label{sec:implementation.Bot}


\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{bilder/FirstTurn}
\caption{Ablauf des ersten Zugs des Spiels}
\label{fig:firstTurn}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{bilder/Turn}
\caption{Ablauf der weiteren Züge des Spiels}
\label{fig:turn}
\end{figure}

Als Basis für unsere Bot Implementation haben wir den Beispiel-Bot verwendet, der im Java-Starter-Package enthalten ist, das von der AI-Challenge-Website heruntergeladen werden kann. Dieser erbt von den Klassen AbstractSystemInputReader und AbstractSystemInputParser, die die Interaktion mit der Spiele-Engine über die System-Input/Output Streams kapseln. Für eine optimierte Lösung könnte der Bot auch angepasst werden, indem er selber auf die Streams zugreift. Im Rahmen dieser Arbeit erschien uns das aber noch nicht nötig.

\subsection{Ablauf eines Zugs} 
\label{sec:implementation.Bot.Turn}
Abbildung \ref{fig:firstTurn} zeigt den Ablauf des ersten Zugs, während Abbildung \ref{fig:turn} den Ablauf aller weiteren Züge zeigt. 

Jeder Zug beginnt mit dem Einlesen des Inputs vom SystemInputStream. Wenn der Bot das Signal ''READY`` (1. Zug) oder ''GO`` (alle weiteren Züge) erhält, kann er den gesammelten Input verarbeiten (Methode parseSetup() resp. parseUpdate()). Danach wird die eigentliche Logik des Bots ausgeführt.

Im 1. Zug werden dabei Instanzen der Tasks erstellt. Abgesehen davon unterscheidet sich der 1. Zug von diesem Punkt an nicht mehr von allen nachfolgenden Zügen. Die Tasks werden vorbereitet (Aufruf der jeweiligen setup() Methode; danach werden einige statistische Werte aktualisiert und in jedem 10. Zug auch geloggt. Dann werden die Tasks in der definierten Reihenfolge aufgerufen. Hier wird der Löwenanteil der Zeit verbracht, denn die Tasks enthalten die eigentliche Logik unserer Ameisen.

Zum Schluss werden dann mit issueOrders() die Züge der Ameisen über den SystemOutputStream an die Spielengine übergeben.


\section{Pfadsuche}
\label{sec:implementation.Pfadsuche}
Wir haben drei mögliche Pfadalgorithmen in unserem Code eingebaut. Via PathFinder-Klasse kann für die Pfadsuche der Algorithmus ausgewählt werden.


\subsection{Simple Algorithmus}
\label{subsec:implementation.Pfadsuche.Simple}

Der Simple Algorithmus versucht das Ziel zu erreichen indem er zuerst die eine, dann die andere Achse abläuft. Sobald ein Hindernis in den Weg kommt, bricht der Algorithmus ab. In der Abbildung \ref{fig:SimplePath} sucht der Algorithmus zuerst den Vertikal-Horizontal Pfad. Da dieser Pfad wegen dem Wasserhindernis (blau) nicht ans Ziel führt, wird via Horizontal-Vertikal Pfad gesucht. Hier wird ein Pfad gefunden. Dieser Algorithmus ist, wie der Name bereits aussagt, sehr einfach aufgebaut und kostet wenig Rechenzeit. Dafür kann er keinen Hindernissen ausweichen.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{bilder/simplepath}
\caption{Simple-Path Algorithmus}
\label{fig:SimplePath}
\end{figure}

\subsection{A* Algorithmus}
\label{subsec:implementation.Pfadsuche.Astar}
Beim A* Algorithmus werden für jeden expandierten Knoten die geschätzten Kosten f(x) für die gesamte Pfadlänge berechnet. f(x) besteht aus einem Teil g(x) welches die effektiven Kosten vom Startknoten zum aktuellen Knoten berechnet. Der andere Teil h(x) ist ein heuristischer Wert, der die Pfadkosten bis zum Zielknoten approximiert. Dieser Wert muss die effektiven Kosten zum Ziel immer unterschätzen. Dies ist in unserem Spiel dadurch gegeben, dass sich die Ameisen nicht diagonal bewegen können, wir aber für den heuristischen Wert die Luftlinie zum Ziel verwenden. Die Pfadsuche wird immer bei dem Knoten fortgesetzt welcher die kleinsten Kosten f(x) hat.

Die Abbildung \ref{fig:heuristicAstar} zeigt den effektiven Pfad (grau) vom zu expandierenden roten Knoten mit den minimalen Kosten von 10 Pixel. Die Luftlinie (blau) als heuristischer Wert hat aber nur eine Länge von 7.6 Pixel. Damit erfüllt unsere Heuristik die Anforderungen des Algorithmus.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{bilder/heuristicAstar.png}
\caption[A* Pfadsuche]{Heuristische Kosten (blau), Effektive Kosten (grau)}
\label{fig:heuristicAstar}
\end{figure}

Dieser A*-Algorithmus wird in unserem Code für eine Pfadsuche über alle Pixel (jedes Pixel ist ein Node) verwendet. Der gleiche Code wir aber auch für die Pfadsuche mit dem Pfadnetz des HPA* verwendet.

\subsection{HPA* Algorthmus}
\label{subsec:implementation.Pfadsuche.HPAstar}

Eine Pfadsuche A* über alle Pixel ist sehr teuer, da es viel Pfade gibt, die zum Teil nur ein Pixel nebeneinander liegen. Es werden bis zum Schluss verschiedenen Pfaden nachgegangen. Abhilfe zu dieser sehr feinmaschigen Pfadsuche bietet der Hierarchical Pathfinding A* bei welchem im sogenanten Clustering über mehrere Pixel verlaufende Kanten und Knoten berechnet werden.

\subsubsection{Clustering}
Das Clustering wird während dem ClusteringTask ausgeführt, Dabei wird die Landkarte in sogenannte Clusters unterteilt. Auf dem Bild \ref{fig.clusteredMap} wurde die Karte in 16 Clusters aufgeteilt. 

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{bilder/clusteredMap.png}
\caption[Clustereinteilung auf der Landkarte.]{Clustereinteilung auf der Landkarte. Clustergrösse 4x4, Landkarte 16x16}
\label{fig.clusteredMap}
\end{figure}

Danach werden für jeden Cluster und einen Nachbar-Cluster aus der Vierer-Nachbarschaft die Verbindungskanten berechnet. Dies kann natürlich nur für Clusters gemacht werden die auf einem sichtbaren Teil der Landkarte liegen, was zu Begin des Spiel nicht gegeben ist. Deshalb wird der ClusteringTask in jedem Spielzug aufgerufen, in der Hoffnung ein Cluster komplett verbinden zu können. Sobald eine beliebige Seite eines Clusters berechnet ist, wird diese Aussenkante im Cluster und dem anliegenden Nachbar gespeichert und nicht mehr neu berechnet.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{bilder/clusteredMap2.png}
\caption[Cluster mit berechneten Kanten]{Die Kanten jedes Clusters wurden berechnet}
\label{fig.clusteredMap2}
\end{figure}

Sobald ein Cluster zwei oder mehrere Aussenkanten kennt berechnet er die Innenkanten mit A* welche die Knoten der Aussenkanten verbinden. Dies ergibt nun ein Pfadnetz über die Gesamtkarte. Im nachfolgenden Bild sind die Innenkanten (gelb) ersichtlich, die bei den ersten 8 Cluster berechnet wurden.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{bilder/clusteredMap3.png}
\caption[Cluster mit Innenkanten]{Darstellung der Innenkanten}
\label{fig.clusteredMap3}
\end{figure}

In der Abbildung \ref{fig.clusteredMap4} wird ein Pfad vom Pixel (3,9) nach (13,9) mittels HPA* gesucht (grüne Punkte). Zuerst wird eruiert in welchem Cluster sich das Start- bzw Zielpixel befindet. Danach wird in dem gefundenen Cluster ein Weg zu einem beliebigen Knoten auf der Clusterseite gesucht. Sind diese Knoten erreicht (blaue Pfade), wird nun das vorberechnete Pfadnetz mittels bereits beschrieben A* Algorithmus verwendet um die beiden Knoten auf dem kürzesten möglichen Pfad (gelb) zu verbinden.\footnote{Der resultierende Pfad könnte mittels Pathsmoothing verkürzt werden. Dies wurde aber in unserer Arbeit nicht implementiert.}

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{bilder/clusteredMap4.png}
\caption{Errechneter Weg mittels HPA*}
\label{fig.clusteredMap4}
\end{figure}

\section{JavaScript Addon für HMTL-Gameviewer}
\label{sec:implementation.Addon}
Das Codepaket welches von den Challenge-Organisatoren mitgeliefert wird, bietet bereits eine hilfreiche 2D-Visualisierung des Spiels, mit welchem das Spielgeschehen mitverfolgt werden kann. Die Visualisierung wurde mit HMTL und Javascript implementiert. Leider ist es nicht möglich zusätzliche Informationen auf die Seite zu projizieren. Deshalb haben wir den Viewer mit einer solchen Funktion erweitert. Mit der Codezeile Logger.liveInfo(...) kann eine Zusatzinformation geschrieben werden. Es muss definiert werden mit welchem Zug und wo auf dem Spielfeld die Infomation angezeigt werden soll. Im Beispiel wird an der Position der Ameise ausgegeben welchen Task die Ameise hat.
\begin{verbatim}
Logger.liveInfo(Ants.getAnts().getTurn(), ant.getTile(), 
                "Task: %s ant: %s", issuer, ant.getTile());
\end{verbatim}
Auf der Karte wird ein einfaches aber praktisches Popup mit den geschriebenen Informationen angezeigt. Dank solcher Zusatzinformationen muss nicht mühsam im Log nachgeschaut werden, welcher Ameise wann und wo welcher Task zugeordnet ist.

\begin{figure}[H]
\centering
\includegraphics[height=70mm]{bilder/javascriptAddon.png}
\caption[Live-Info Popup]{Das Popup zeigt die Aufgabe und den Pfad (blau), welcher die Ameise ablaufen wird.}
\label{fig.javascriptAddon}
\end{figure}

Das angezeigte Popup zeigt welchen Task (GatherFoodTask) die Ameise hat, wo sie sich befindet <r:28 c:14>, welches Futterpixel angesteuert wird <r:35 c:13> und welchen Pfad dazu berechnet wurde. 