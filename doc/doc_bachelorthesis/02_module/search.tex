\chapter{Suchalgorithmen}
\label{sec:module.Suchalgorithmen}

\section{Enities für die Pfadsuche}
\label{sec:module.Suchalgorithmen.Enities}

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{91_bilder/pathfinderPathfinder}
\caption{Klassendiagramm Pfadsuche}
\label{fig:pathfinderPathfinder}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{91_bilder/pathfinderEntities}
\caption{Spiel-Elemente für die Suche (vereinfacht)}
\label{fig:pathfinderEntities}
\end{figure}


TODO NEW IMAGE

Abbildung \ref{fig:pathfinderEntities} zeigt die wichtigsten Klassen, die für die Pfadsuche verwendet werden. Der \"Ubersichtlichkeit wegen wurden nur die wichtigsten Attribute und Operationen in das Diagramm aufgenommen.

\section{Pfadsuche}
\label{sec:module.Suchalgorithmen.Pfadsuche}
Wir haben drei mögliche Pfadalgorithmen in unserem Code eingebaut. Via PathFinder-Klasse kann für die Pfadsuche der Algorithmus ausgewählt werden.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{91_bilder/pathfinderSearch}
\caption{Suchstrategien}
\label{fig:pathfinderSearch}
\end{figure}

\subsection{Simple Algorithmus}
\label{subsec:module.Suchalgorithmen.Pfadsuche.Simple}

Der Simple Algorithmus versucht das Ziel zu erreichen indem er zuerst die eine, dann die andere Achse abläuft. Sobald ein Hindernis in den Weg kommt, bricht der Algorithmus ab. In der Abbildung \ref{fig:SimplePath} sucht der Algorithmus zuerst den Vertikal-Horizontal Pfad. Da dieser Pfad wegen dem Wasserhindernis (blau) nicht ans Ziel führt, wird via Horizontal-Vertikal Pfad gesucht. Hier wird ein Pfad gefunden. Dieser Algorithmus ist, wie der Name bereits aussagt, sehr einfach aufgebaut und kostet wenig Rechenzeit. Dafür kann er keinen Hindernissen ausweichen.

\begin{figure}[H]
\centering

\includegraphics[height=50mm]{91_bilder/simplepath}
\caption{Simple-Path Algorithmus}
\label{fig:SimplePath}
\end{figure}

Folgendes Codesnippet zeigt auf wie ein Pfad mittels Pfadsuche Simple gefunden wird. Ein SimplePathFinder wird mit der Karte initialisiert. Danach kann die Suche mit pf.search(...) gestartet werden. Als Parameter wird der Suchalgorithmus Strategy.Simple, der Startpunkt (Position der Ameise) und Endpunkt (Position des Futters), sowie die maximalen Pfadkosten (hier: 16) mitgegeben.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
SimplePathFinder pf = new SimplePathFinder(map);
List<Tile> path = pf.search(PathFinder.Strategy.Simple, ant.getTile(), foodTile,16);
\end{lstlisting}

\subsection{A* Algorithmus}
\label{subsec:module.Suchalgorithmen.Pfadsuche.Astar}
Beim A* Algorithmus werden für jeden expandierten Knoten die geschätzten Kosten f(x) für die gesamte Pfadlänge berechnet. f(x) besteht aus einem Teil g(x) welches die effektiven Kosten vom Startknoten zum aktuellen Knoten berechnet. Der andere Teil h(x) ist ein heuristischer Wert, der die Pfadkosten bis zum Zielknoten approximiert. Dieser Wert muss die effektiven Kosten zum Ziel immer unterschätzen. Dies ist in unserem Spiel dadurch gegeben, dass sich die Ameisen nicht diagonal bewegen können, wir aber für den heuristischen Wert die Luftlinie zum Ziel verwenden. Die Pfadsuche wird immer bei dem Knoten fortgesetzt welcher die kleinsten Kosten f(x) hat.

Die Abbildung \ref{fig:heuristicAstar} zeigt den effektiven Pfad (grau) vom zu expandierenden roten Knoten mit den minimalen Kosten von 10 Pixel. Die Luftlinie (blau) als heuristischer Wert hat aber nur eine Länge von 7.6 Pixel. Damit erfüllt unsere Heuristik die Anforderungen des Algorithmus.

Eine Pfadsuche mit A* wird gleich ausgelöst wie die Suche mit dem Simple-Algorithmus, ausser dass als Parameter die Strategy AStar gewählt wird.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
SimplePathFinder pf = new SimplePathFinder(map);
List<Tile> path = pf.search(PathFinder.Strategy.AStar, ant.getTile(), foodTile,16);
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{91_bilder/heuristicAstar.png}
\caption[A* Pfadsuche]{Heuristische Kosten (blau), Effektive Kosten (grau)}
\label{fig:heuristicAstar}
\end{figure}

Dieser A*-Algorithmus wird in unserem Code für eine Pfadsuche über alle Pixel (jedes Pixel ist ein Node) verwendet. Der gleiche Code wir aber auch für die Pfadsuche mit dem Pfadnetz des HPA* verwendet.

\subsection{HPA* Algorthmus}
\label{subsec:module.Suchalgorithmen.Pfadsuche.HPAstar}

Eine Pfadsuche A* über alle Pixel ist sehr teuer, da es viel Pfade gibt, die zum Teil nur ein Pixel nebeneinander liegen. Es werden bis zum Schluss verschiedenen Pfaden nachgegangen. Abhilfe zu dieser sehr feinmaschigen Pfadsuche bietet der Hierarchical Pathfinding A* bei welchem im sogenannten Clustering über mehrere Pixel verlaufende Kanten und Knoten berechnet werden.

\subsubsection{Clustering}
Das Clustering wird während dem ClusteringTask ausgeführt, Dabei wird die Landkarte in sogenannte Clusters unterteilt. Auf dem Bild \ref{fig.clusteredMap} wurde die Karte in 16 Clusters aufgeteilt.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{91_bilder/clusteredMap.png}
\caption[Clustereinteilung auf der Landkarte.]{Clustereinteilung auf der Landkarte. Clustergrösse 4x4, Landkarte 16x16}
\label{fig.clusteredMap}
\end{figure}

Wir unterschieden zwischen den zwei Clusterarten Centered und Corner. Die Variante Corner wurde bereits im Vormodule 'Projekt 2' implementiert während die Variante Corner im Laufe dieser Arbeit dazu kam. Folgendes Bild zeigt den Unterschied der Varianten. Corner generiert zwei Übergangspunkte plus eine Verbindung auf der Kante zwischen zwei Clusters während Centered nur einen Übergangspunkt in der Mitte des Übergangs generiert. Die Variante Centered hat den Vorteil, dass es weniger Pfade zum durchlaufen gibt. Aber sie hat auch den Nachteil, dass der gefunden Pfad, nicht in jedem Fall der Kürzeste ist und ein Pathsmoothing gemacht werden muss.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{91_bilder/clusterArten.png}
\caption[Clustereinteilung auf der Landkarte.]{Vergleich der Clusterarten: Links der Typ Corner, Rechts der Typ Centered}
\label{fig.clusteredMap}
\end{figure}

Nachfolgend wir erläutert wie das Clustering vonstatten geht, verwendet wird die Custeringart Corner.\\
Nach dem Einteilen der Cluster werden für jeden Cluster und einen Nachbar-Cluster aus der Vierer-Nachbarschaft die Verbindungskanten berechnet. Dies kann natürlich nur für Clusters gemacht werden die auf einem sichtbaren Teil der Landkarte liegen, was zu Begin des Spiel nicht gegeben ist. Deshalb wird der ClusteringTask in jedem Spielzug aufgerufen, in der Hoffnung ein Cluster komplett verbinden zu können. Sobald eine beliebige Seite eines Clusters berechnet ist, wird diese Aussenkante im Cluster und dem anliegenden Nachbar gespeichert und nicht mehr neu berechnet.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{91_bilder/clusteredMap2.png}
\caption[Cluster mit berechneten Kanten]{Die Kanten jedes Clusters wurden berechnet}
\label{fig.clusteredMap2}
\end{figure}

Sobald ein Cluster zwei oder mehrere Aussenkanten kennt berechnet er die Innenkanten mit A* welche die Knoten der Aussenkanten verbinden. Dies ergibt nun ein Pfadnetz über die Gesamtkarte. Im nachfolgenden Bild sind die Innenkanten (gelb) ersichtlich, die bei den ersten 8 Cluster berechnet wurden.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{91_bilder/clusteredMap3.png}
\caption[Cluster mit Innenkanten]{Darstellung der Innenkanten}
\label{fig.clusteredMap3}
\end{figure}

In der Abbildung \ref{fig.clusteredMap4} wird ein Pfad vom Pixel (3,9) nach (13,9) mittels HPA* gesucht (grüne Punkte). Zuerst wird eruiert in welchem Cluster sich das Start- bzw Zielpixel befindet. Danach wird in dem gefundenen Cluster ein Weg zu einem beliebigen Knoten auf der Clusterseite gesucht. Sind diese Knoten erreicht (blaue Pfade), wird nun das vorberechnete Pfadnetz mittels bereits beschrieben A* Algorithmus verwendet um die beiden Knoten auf dem kürzesten möglichen Pfad (gelb) zu verbinden. Der resultierende Pfad könnte kann nun via Pathsmoothing verkürzt werden.

\begin{figure}[H]
\centering
\includegraphics[height=50mm]{91_bilder/clusteredMap4.png}
\caption{Errechneter Weg mittels HPA*}
\label{fig.clusteredMap4}
\end{figure}

Um eine Pfadsuche mit HPA* durchzuführen muss ein ClusteringPathFinder instanziert werden. Als Parameter erwartet der Konstruktor die Karte auf welcher das Clustering und die Pfadsuche gemacht wird, sowie die Clustergrösse (hier: 10) und den Clustertyp. Das Clustering wird mit pf.update() durchgeführt. Danach kann die Pfadsuche durchgeführt werden. Falls das Clustering auf dem benötigten Kartenausschnitt nicht komplett durchgeführt werden konnte, weil nicht alle Tiles in einem Cluster sichtbar waren, wird versucht mit A* einen Pfad zu suchen.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
ClusteringPathFinder pf = new ClusteringPathFinder(map, 10, type);
pf.update();
List<Tile> path = pf.search(PathFinder.Strategy.HpaStar, start, end, -1);
\end{lstlisting}

\subsection{Pfadsuche mittels Influence Map}
\label{subsec:module.Suchalgorithmen.Pfadsuche.WithInfluenceMap}

Die Influence Map, welche wir während der Bachelorarbeit neu implementiert haben, kann auch für die Pfadsuche verwendet werden. Dabei sind die Pfadkosten für Gebiete in die vom Gegner kontrolliert sind höher als für neutrale Gebiete und tiefer für solche Gebiete die von unseren Ameisen kontrolliert werden. (Details zur Implementierung der InfluenceMap sieh Kapitel TODO) Die Methode getActualCost(...) in der Klasse SearchStrategy wurde erweitert. Falls die Suche mit einer InfluenceMap initialisiert wurde, sind die Kosten nicht eine Einheit pro Pfadtile, sondern können zwischen 1 (sicheres Gebiet) - 4 (gefährliches Gebiet) Einheiten variieren. (Die Pfadkosten dürfen nicht negativ sein, sonst würde der A* Algorithmus nicht mehr korrekt funktionieren.) Die Kosten für jeden Pfadabschnitt werden durch die Methode getPathCosts(...) der InfluenceMap berechnet.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
protected final int getActualCost(Node current, PathPiece piece) {
    int costOfPiece = 0;
    if (useInflunceMap)
        costOfPiece = pathFinder.getInfluenceMap().getPathCosts(piece);
    else
        costOfPiece = piece.getCost();
    return current.getActualCost() + costOfPiece;
}
\end{lstlisting}

Dadurch resultiert ein Pfad der durch sicheres Gebiet führt. Folgende Ausgabe, welche durch einen UnitTest generiert wurde, bezeugt die korrekte Funktionalität. Der rote Punkt soll mit dem schwarzen Punkt durch einen Pfad verbunden werden. Auf der Karte sind zudem die eigenen, orangen Einheiten sowie die gegnerischen Einheiten (blau) abgebildet. Jede Einheit trägt zur Berechnung der InfluenceMap bei. Pro Tile wird die Sicherheit ausgegeben, negativ für Gebiete die vom Gegner kontrolliert werden und positiv in unserem Hoheitsgebiet.

\begin{figure}[H]
\centering
\includegraphics[width=0.99\textwidth]{91_bilder/influenceAStar01.jpg}
\caption{Ausgangslage Pfadsuche mit A* und InfluenceMap}
\label{fig.InfluenceAndPathfinding01}
\end{figure}

Ohne Berücksichtigung der InfluenceMap würde der A* Algorithmus einen Pfad finden der auf direktem Weg waagrecht zum Zielpunkt führt. Sobald aber die InfluenceMap berücksichtigt wird, führt der Pfad nicht mehr auf dem direktesten Weg zum Ziel, sondern nimmt einen Umweg über sicheres Gebiet. Unten abgebildet ist der kürzeste Pfad mit Berücksichtigung der InfluenceMap (blau) und ohne InfluenceMap-Berücksichtigung (orange). 

\begin{figure}[H]
\centering
\includegraphics[width=0.99\textwidth]{91_bilder/influenceAStar02.jpg}
\caption{Resultierende Pfade mit und ohne Berücksichtigung der InfluenceMap}
\label{fig.InfluenceAndPathfinding02}
\end{figure}

Die Pfadkosten für beide Pfade verglichen, legt offen, dass je nach Berücksichtigung der InfluenceMap nicht der gleiche Pfad als der 'Kürzeste' von A* gefunden wird.

\renewcommand{\arraystretch}{1.5}
\begin{table}[H]
	\centering
\begin{tabular}{l | r r}
 & Kosten ohne InfluenceMap &Kosten mit InfluenceMap \\
\hline
 Oranger Pfad & \textbf{34} & 110 \\
 Blauer Pfad & 46 & \textbf{106} \\
 \end{tabular}
 \caption{Pfadkosten mit und ohne Berücksichtigung der InfluenceMap}
\end{table}
 
\subsection{Pathsmoothing}
\label{subsec:module.Suchalgorithmen.Pfadsuche.Pathsmoothing}

Um unseres Search-Framework zu komplettieren bietet die Pfadsuche auch ein PathSmoothing, das 'Glätten' eines Pfades an. Wie im Clustering schon erwähnt, kann es sein, dass ein Pfad, der von dem HPA* Algorithmus gefunden wurde, nicht zwingend der Kürzeste ist. Die folgende Abbildung veranschaulicht wie der gefundene Pfad von Cluster zu Cluster (weisse Markierung), stets über die vorberechneten Verbindungspunkte (blau) verläuft. Dies ist nicht der optimale Pfad, er kann mit PathSmoothing verkürzt werden.

\begin{figure}[H]
\centering
\includegraphics[width=0.99\textwidth]{91_bilder/pathsmoothingOne}
\caption{Der gefundene Pfad mit HPA* Clusteringart Centered, ist nicht der kürzeste.}
\label{fig.pathsmoothingOne}
\end{figure}

Der Algorithmus des Pathsmoothing ist (vereinfacht) wie folgt definiert. Vom Pfad der gekürzt werden soll wird ein erster Abschnitt mit der Länge \textit{size} genommen. Mittels manhattanDistance wird geprüft ob eine kürzere Weg für diesen Abschnitt möglich wäre. Falls ja wird mittels A* ein neuer Pfad gesucht, sonst wird der alte Pfad (\textit{subPath} übernommen. Dieses Verfahren wird für alle nachfolgenden Pfadabschnitte gemacht, bis der ganze Pfad durchlaufen ist.\\
\\
\textbf{Rekursion:} Der beschriebene Algorithmus, hat nicht in jedem Fall den kürzesten Pfad als Output. So sind zwar alle Pfadabschnitte optimal gekürzt, es kann aber sein, dass wenn zwei Abschnitte zusammen gefügt werden, der Pfad nicht mehr der kürzeste ist. Als Beispiel: Die Wegabschnitt Zürich-Thun und Thun-Genf mögen optimal gekürzt sein. Zusammengefügt zur Strecke Zürich-Genf, braucht es den Umweg über Thun nicht. Um Umweg zu entfernen wird der Algorithmus rekursiv aufgerufen, indem smoothPath(...) mit einer grösseren \textit{size} als Parameter für die zusammengesetzten Abschnitte nochmals aufgerufen wird.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
public List<Tile> smoothPath(List<Tile> path, int size, boolean recursive) {
	int start = 0;
	int current = size;
	List<Tile> smoothedPath = new ArrayList<Tile>();
	// do while the last tile of the smoothed path is the same as in path
	do {
	    List<Tile> subPath = path.subList(start, current);
	    int manDist = map.manhattanDistance(subPath.get(0), subPath.get(subPath.size() - 1)) + 1;	
	    List<Tile> newSubPath = null;
	    if (manDist < subPath.size()) {
	        newSubPath = search(Strategy.AStar, subPath.get(0), subPath.get(subPath.size() - 1), subPath.size() - 1);
	    }
	    if (newSubPath != null) {
	        smoothedPath.addAll(newSubPath);
	        if (recursive && newSubPath.size() < subPath.size()) {
	            smoothedPath = smoothPath(smoothedPath, smoothedPath.size(), true);
	        }
	    } else {
	        smoothedPath.addAll(subPath);
	    }
	    start = current;
	    current = Math.min(current + size, path.size());
} while (!path.get(path.size() - 1).equals(smoothedPath.get(smoothedPath.size() - 1)));

return smoothedPath;
}
\end{lstlisting}

In der nächsten Abbildung wurde der beschriebene PathSmoothing Algorithmus angewendet, der Pfad konnte einer ursprünglichen Pfadlänge   von 50 Tiles (siehe \ref{fig.pathsmoothingOne}) auf eine Pfadlänge von 40 Tiles reduziert werden.

\begin{figure}[H]
\centering
\includegraphics[width=0.99\textwidth]{91_bilder/pathsmoothingTwo}
\caption{Der geglättete Pfad, nach Anwendung des PathSmoothing-Algorithmus}
\label{fig.pathsmoothingTwo}
\end{figure}