\chapter{Strategie und Taktik}
\label{sec:module.StrategieTaktik}


\section{Influence Map}
\label{sec:module.InfluenceMap}
\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{91_bilder/strategyInfluence}
\caption{Influence Map Klassendiagramm}
\label{fig.strategyInfluence}
\end{figure}

Die InfluenceMap haben wir nach den Beschreibungen in \cite{ARTIFICIALINTELLIGENCEFORGAMES} implementiert. Jede bekannte Spieleinheit auf der Spielkarte 'strahlt' eine gewissen Einfluss aus. In unserer Implementation unterscheiden wir zwischen drei Einflussradien, der Angriffsradius, der erweiterte Angriffsradius und der Sichtradius. Den Radien haben wir folgende Werte zugewiesen. 

\renewcommand{\arraystretch}{1.5}
\begin{table}[H]
	\centering
\begin{tabular}{l | r r}
 Radius & Wert & Radius in Tiles* \\
\hline
 Angriffsradius & 50 & 2.2 \\
 Erweiterter Angriffsradius & 30 & 5  \\
 Sichtradius & 10 & 8.8 \\
 \end{tabular}
\caption{Einfluss einer Spieleinheit}
\end{table}
 
 * Der Radius kann je nach Spieleinstellungen ändern. Angegeben sind die Defaultwerte.

Wir verenden die InfluenceMap vorallem für die Bestimmung der Sicherheit. Abgebildet ist eine Sicherheitskarte (Desirability Map) für den orangen Spieler, wobei die Einflusswerte des Gegners von den Einflusswerten des eigenen Spielers je Tile subtrahiert werden. Positive Werte bedeuten sicheres Terrain und negative Werte unsicheres, vom Gegner kontrolliertes Gebiet.

\begin{figure}[H]
\centering
\includegraphics[width=0.99\textwidth]{91_bilder/influence01.jpg}
\caption{Influence Map, dargestellt ist die Sicherheit je Tile.}
\label{fig.InfluenceMap01}
\end{figure}

\subsection{Update}
\label{subsec:module.InfluenceMap.Update}

Die InfluenceMap wird zu Beginn des Spiels initialisiert, danach wird vor jeder Spielrunde ein Update gemacht. Dabei definiert ein Decay-Wert zwischen 0 und 1, wieviel von den alten Werten beibehalten wird. Folgende Formel bestimmt den neuen Wert für jede Zelle:


\(val_{(x,y)} = val_{(x,y)} * decay + newval_{(x,y)} * (1-decay)\)


\subsection{Anwendungsfälle}
\label{subsec:module.InfluenceMap.Anwendungsfälle}

In folgenden Modulen berücksichtigen wir Werte aus InfluenceMap um Entscheide zu fällen.

\begin{itemize}
\item
\textbf{Pfadsuche mit InfluenceMap Berücksichtigung}: Siehe Kapitel \ref{subsec:module.Suchalgorithmen.Pfadsuche.WithInfluenceMap}
\item
\textbf{CombatSituation: Flucht}: Müssen wir die Flucht ergreifen, bewegen wir unsere Ameise auf das nächste sicherste Tile.
\item
\textbf{Abbruch Mission}: Falls eine Ameise auf einer andere Mission als die GatherFoodMission ist und ein FoodTile in seiner Nähe antrifft, wird abgewogen ob die Mission zu Gunsten von Futter sammeln abgebrochen werden soll. Dabei ist ein Entscheidungsfaktor auch die 'Sicherheit' des Futters. Falls das Futter nicht auf einem sicheren Weg geholt werden kann, wird die Mission nicht abgebrochen.
\end{itemize}

Natürlich könnte man die InfluenceMap auch für weitere Entscheidungen verwenden. Auch der Einsatz von Spannungskarte (Tension Map), welche auch auf den Werten InfluenceMap aufbaut, wäre denkbar. Dies wurde während dieser Arbeit nicht angeschaut bzw. implementiert.


\section{Combat Situations}
\label{sec:module.CombatSituation}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{91_bilder/strategyTacticsCombat}
\caption{CombatPositioning Klassendiagramm}
\label{fig.strategyTacticsCombat}
\end{figure}

Kampfsituationen treten immer dann auf wenn gegnerische Ameisen auf unsere Ameisen treffen. Zum Beispiel wenn ein gegnerischer Hügel angegriffen wird, oder der eigene Hügel verteidigt werden muss. Eine Kampfsituation kann sich aber auch sonst wo auf der Karte ereignen.

\subsection{DefaultCombatPositioning}
\label{sec:module.CombatSituation.DefaultCombatPositioning}

DefaultCombatPositioning implementiert das Interface CombatPositioning und führt die Positionierung für die drei Verhalten FLEE, DEFEND, ATTACK an. Das Verhalten wird in der Methode \texttt{determineMode(...)} wie folgt bestimmt, wobei das 'DEFAULT' Verhalten dem ATTACK-Verhalten entspricht. (Das Verhalten 'CONTROL' wurde nicht implementiert.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
protected Mode determineMode() {
    final boolean enemyIsSuperior = enemyUnits.size() > myUnits.size();
    if (enemyIsSuperior)
        return Mode.FLEE;
    return Mode.DEFAULT;
}
\end{lstlisting}

Wenn nicht ein DefaultCombatPositioning initialisiert wird, sondern ein AttackingCombatPositioning (in der AttackHillMission) oder ein DefendingCombatPositioning (in der DefendHillMission) so wird das Verhalten anders bestimmt, indem die \texttt{determineMode(...)}  Methode überschrieben ist.\\
\\
\textbf{DefendingCombatPositioning}

Hier wird immer das 'DEFEND' Verhalten ausgewählt, aus dem Grund, dass die Verteidiger sich nicht zu weit vom Hügel entfernen in dem sie den Gegner attackieren und der Hügel von einer anderen Seite eingenommen wird. In Unterzahl sollen die Verteidiger auch nicht flüchten, sondern trotzdem Versuchen den Hügel zu verteidigen. Hier könnte man sich Gedanken machen ob die Verteidiger, falls in Überzahl, die Gegner nicht bis zu einem gewissen Punkt angreifen sollen. Dieser Möglichkeit sind wir aber nicht weiter nach gegangen.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
protected Mode determineMode() {
    return Mode.DEFEND;
}
\end{lstlisting}

\textbf{AttackingCombatPositioning}

Die Bestimmung des Verhalten unserer Angreifern in der AttackingCombatPositioning-Klasse ist da schon komplexer. Mittels Breitensuche werden die Gegner zwischen uns und dem Ziel ermittelt. Falls der Gegner in Unterzahl ist wird angegriffen, indem der Modus auf ATTACK gesetzt wird. Andernfalls greift die \texttt{determineMode(...)} des DefaultCombatPositioning.

TODO DISCUSS

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
@Override
protected Mode determineMode() {
    Tile clusterCenter = map.getClusterCenter(myUnits);
    BreadthFirstSearch bfs = new BreadthFirstSearch(map);
    int distanceToTarget = map.getSquaredDistance(clusterCenter, target);
    List<Tile> enemiesGuardingTarget = bfs.floodFill(target, distanceToTarget, new GoalTest() {
        @Override
        public boolean isGoal(Tile tile) {
            return enemyUnits.contains(tile);
        }
    });
    if ((enemiesGuardingTarget.size() * 2) <= myUnits.size())
        return Mode.ATTACK;

    // fall back to default
    return super.determineMode();
}
\end{lstlisting}

Die bereits erwähnten Verhalten, nehmen folgende Positionierung der Ameisen vor.

\subsubsection{FLEE}
\label{sec:module.CombatSituation.DefaultCombatPositioning.Flee}

Für jede Unit wird die sicherste Nachbarzelle mittels InfluenceMap bestimmt. Die Unit verschieb sich auf die sicherste Nachbarzelle, welche logischerweise vom Gegner entfernt liegt.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}
for (Tile myUnit : myUnits) {
    nextMoves.put(myUnit, map.getSafestNeighbour(myUnit, influenceMap));
}
\end{lstlisting}

\subsubsection{DEFEND}
\label{sec:module.CombatSituation.DefaultCombatPositioning.Defend}

Der Modus DEFEND wird verwendet um ein Ort, bei uns unsere eigenen Hügel, zu verteidigen. Der Algorithmus definiert sich wie folgt.

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption=Algorithmus zur Verteidigung]
private void defendTarget() {
	// if no opponents are around, just position ourselves in the diagonals
	if (enemyUnits.isEmpty()) {
	    move enemies to the diagonals of of the defend tile
	} else {
		// some sides mustn't be defend because they are surrounded by water
		calculate sides to defend
			        
		foreach(side in sides to defend) {
				calculate attackers on this side
				calculate clustercenter of  enemy
				calculate defenders for this side
		    calculate defend positions
		    positioning of the defenders 
		}
	}
}
\end{lstlisting}

Das ClusterCenter des Gegners ist jeweils der Schwerpunkt aller Einheiten des Gegners und wir, wie später erklärt, für die Positionierung der eigenen Ameisen verwendet. Das Berechnen der Verteidiger je Seite beanspruchte im Code ein bisschen mehr als eine Zeile: Alle Ameisen die bereits in einer Richtung sind von welcher angegriffen wird, werden dieser Verteidigungsrichtung zugewiesen. Die restlichen Ameisen werden der Richtung zugewiesen von wo sich am meisten Angreifer nähern. So sind nun Verteidiger und Angreifer je Seite ausgemacht und es folgt die Positionierung.\\
Das ClusterCenter des Gegners dient als Kreismittelpunkt (siehe schwarzer Kreis in Abb. \ref{fig.DefaultCombatPositioning}). Der Radius ergibt sich zwischen dem ClusterCenter der eigenen Verteidiger und dem ClusterCenter des Gegners. Auf diesem Kreisumfang werden, mit Start bei unserem ClusterCenter, mittels Breitensuche so viele Tiles zur Positionierung gesucht wie Verteidiger zur Verfügung stehen. Danach werden die Verteidiger auf den gefundenen Tiles positioniert.

\begin{figure}[H]
\centering
\includegraphics[height=40mm]{91_bilder/DefendingCombatSituation00}
\caption{DefaultCombatPositioning: Berechnung der Tiles für die Positionierung}
\label{fig.DefaultCombatPositioning}
\end{figure}

Abbildung \ref{fig.DefaultCombatPositioning} zeigt wie die Tiles zur Positionierung für die südliche und die nördliche Verteidigung berechnet werden. Die schwarzen Kreise siginfieren die ClusterCenter der Kontrahenten. Die gefundenen Positionierungstiles für die nördliche Verteidigung liegen auf dem grauen Kreis und werden in der Abbildung hellorangen dargestellt. Zu sehen ist auch, dass auf dem eigenen Hügel kein Positionierung möglich ist, hier sollen neue Ameisen schlüpfen können.\\
\\
Die Idee dieser Positionierung ist, dass so alle eigene Ameisen gleich weit vom Zentrum des Gegners entfernt sind. Sobald der Gegner vorrückt muss er gegen alle Ameisen gleichzeitig kämpfen. Nachteil dieser Positionierung ist, dass wenn der Gegner nicht kompakt angreift und nicht eine gleichförmige Angriffsformation hat, richten wir uns nur nach dem ClusterCenter aus, die einzelnen Gruppierungen der gegnerischen Ameisen werden nicht berücksichtigt, was ein Nachteil bei der Verteidigung zur Folge hat.\\
Wir haben uns überlegt, dass eine Positionierung mit Hilfe der InfluenceMap diesen Nachteil beheben würde. Man könnte die neutralen Tiles die sich zwischen den Kontrahenten befindet mittels InfluenceMap herausfinden und als Front anschauen. Nach dieser Frontlinie würden wir uns dann unsere Einheiten ausrichten Leider fehlte uns hier die Zeit dies nachträglich noch zu programmieren und auszuprobieren.

\subsubsection{ATTACK}
\label{sec:module.CombatSituation.DefaultCombatPositioning.Attack}

\lstset{language=Java, tabsize=4}
\begin{lstlisting}[caption=Algorithmus zur Berechnung der Angriffsformation]
 private void attackTarget() {
 		find all enemies in target direction
 		if(no enemies around){
 			move all unit in direction of the target
 		}else{
 			 calculate clustercenter of  enemy
 			 calcuate attack positions
 			 if(more than x friendly unit are already on the formation tiles)
 			 		 calcuate formation tiles nearer to the enemy
 			 positioning of the attackers
 		}
 }
\end{lstlisting}

Im Verhalten ATTACK werden die Tiles zur Positionierung genau gleich berechnet wie vorhin im DEFEND-Modus. Nach der Berechnung wird geschaut wie viele unserer Angreifer schon auf diesen Tiles sind. Falls sich ein definierbarer Anteil der Ameisen bereits auf den Tiles befindet, gehen wir davon aus das sich unsere Ameisen formiert haben und wird der Radius verkürzt. Durch den verkürzten Radius werden Tiles berechnet die um eine Zelle näher beim Gegner sind. Danach folgt die Positionierung (Vorrücken) der Ameisen auf die berechneten Tiles.